#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
T3 v1.3：综合增强版Y染色体浓度达标时间分析
整合T2 v2.2思路，实现前后逻辑连贯的完整分析

主要特点：
1. 整合T2 v2.2的非重叠分组算法
2. 增强的多维风险函数评估
3. 个性化NIPT时点预测
4. 改进的交叉验证框架
5. 详细的临床决策支持
6. 前后逻辑连贯的完整分析流程
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from scipy.optimize import minimize_scalar
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from sklearn.metrics import silhouette_score, adjusted_rand_score
from sklearn.model_selection import StratifiedKFold
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import os
from datetime import datetime
import json
import warnings
warnings.filterwarnings('ignore')

# 设置中文字体显示
plt.rcParams['font.sans-serif'] = ['SimHei', 'DejaVu Sans', 'Liberation Sans', 'sans-serif']
plt.rcParams['axes.unicode_minus'] = False

class T3IntegratedAnalysis:
    def __init__(self):
        self.data = None
        self.male_data = None
        self.analysis_results = {}
        self.grouping_results = {}
        self.risk_analysis = {}
        
    def load_and_preprocess_data(self):
        """数据加载与预处理"""
        print("=== 1. 数据加载与预处理 ===")
        
        # 获取项目根目录
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(script_dir))))
        
        # 读取数据
        data_path = os.path.join(project_root, 'data', 'common', 'source', 'dataA.csv')
        self.data = pd.read_csv(data_path, header=None)
        
        # 列名映射
        columns = ['样本序号', '孕妇代码', '孕妇年龄', '孕妇身高', '孕妇体重', '末次月经时间',
                   'IVF妊娠方式', '检测时间', '检测抽血次数', '孕妇本次检测时的孕周', '孕妇BMI指标',
                   '原始测序数据的总读段数', '总读段数中在参考基因组上比对的比例', '总读段数中重复读段的比例',
                   '总读段数中唯一比对的读段数', 'GC含量', '13号染色体的Z值', '18号染色体的Z值',
                   '21号染色体的Z值', 'X染色体的Z值', 'Y染色体的Z值', 'Y染色体浓度',
                   'X染色体浓度', '13号染色体的GC含量', '18号染色体的GC含量', '21号染色体的GC含量',
                   '被过滤掉的读段数占总读段数的比例', '检测出的染色体异常', '孕妇的怀孕次数',
                   '孕妇的生产次数', '胎儿是否健康']
        self.data.columns = columns
        
        # 数值转换
        numeric_columns = ['孕妇年龄', '孕妇身高', '孕妇体重', '孕妇BMI指标',
                          '原始测序数据的总读段数', '总读段数中在参考基因组上比对的比例', 
                          '总读段数中重复读段的比例', '总读段数中唯一比对的读段数', 'GC含量', 
                          '13号染色体的Z值', '18号染色体的Z值', '21号染色体的Z值', 
                          'X染色体的Z值', 'Y染色体的Z值', 'Y染色体浓度',
                          'X染色体浓度', '13号染色体的GC含量', '18号染色体的GC含量', '21号染色体的GC含量',
                          '被过滤掉的读段数占总读段数的比例']
        
        def safe_float_convert(x):
            try:
                return float(x)
            except:
                return np.nan
                
        for col in numeric_columns:
            self.data[col] = self.data[col].apply(safe_float_convert)
        
        # 孕周解析
        def convert_gestational_age(age_str):
            try:
                if isinstance(age_str, str):
                    if '+' in age_str:
                        weeks, days = age_str.split('w+')
                        return float(weeks) + float(days)/7
                    elif 'w' in age_str:
                        return float(age_str.split('w')[0])
                return float(age_str)
            except:
                return np.nan
                
        self.data['孕周数值'] = self.data['孕妇本次检测时的孕周'].apply(convert_gestational_age)
        
        # 筛选男胎数据
        self.male_data = self.data[(self.data['Y染色体浓度'].notna()) & 
                                  (self.data['Y染色体浓度'] > 0)].copy()
        
        # 创建Y染色体浓度达标标签（≥4%）
        self.male_data['Y染色体达标'] = (self.male_data['Y染色体浓度'] >= 0.04).astype(int)
        
        # 计算达标比例
        达标比例 = self.male_data['Y染色体达标'].mean()
        
        print(f"总样本数: {len(self.data)}")
        print(f"男胎样本数: {len(self.male_data)}")
        print(f"Y染色体浓度达标样本数: {self.male_data['Y染色体达标'].sum()}")
        print(f"Y染色体浓度达标比例: {达标比例:.2%}")
        
    def enhanced_bmi_grouping(self):
        """增强的BMI分组分析（整合T2 v2.2思路）"""
        print("\n=== 2. 增强BMI分组分析 ===")
        
        # 准备分组数据
        grouping_data = self.male_data.dropna(subset=[
            '孕妇年龄', '孕妇身高', '孕妇体重', '孕妇BMI指标', '孕周数值', 
            'Y染色体浓度', 'Y染色体达标'
        ]).copy()
        
        # 1. 传统BMI分组
        self.male_data['BMI分组_传统'] = pd.cut(
            self.male_data['孕妇BMI指标'],
            bins=[0, 18.5, 24, 28, 35, np.inf],
            labels=['偏瘦', '正常', '超重', '肥胖', '极度肥胖'],
            include_lowest=True
        )
        
        # 2. 基于T2 v2.2的非重叠分组算法
        bmi_values = grouping_data['孕妇BMI指标'].values
        n_clusters = 3  # 根据T2 v2.2的经验
        
        # 使用KMeans进行初步聚类
        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        cluster_labels = kmeans.fit_predict(bmi_values.reshape(-1, 1))
        
        # 获取聚类中心并排序
        centers = kmeans.cluster_centers_.flatten()
        sorted_indices = np.argsort(centers)
        
        # 创建非重叠分组
        bmi_sorted = np.sort(bmi_values)
        n_samples = len(bmi_sorted)
        
        # 计算分组边界
        group_boundaries = []
        for i in range(n_clusters):
            start_idx = int(i * n_samples / n_clusters)
            end_idx = int((i + 1) * n_samples / n_clusters)
            if i == n_clusters - 1:  # 最后一组包含所有剩余样本
                end_idx = n_samples
            
            group_min = bmi_sorted[start_idx]
            group_max = bmi_sorted[end_idx - 1]
            group_boundaries.append((group_min, group_max))
        
        # 应用分组
        def assign_group(bmi):
            for i, (min_bmi, max_bmi) in enumerate(group_boundaries):
                if min_bmi <= bmi <= max_bmi:
                    return f'组{i}'
            return '组0'  # 默认分组
        
        grouping_data['BMI分组_优化'] = grouping_data['孕妇BMI指标'].apply(assign_group)
        self.male_data['BMI分组_优化'] = self.male_data['孕妇BMI指标'].apply(assign_group)
        
        # 3. 分析各组的Y染色体浓度达标情况
        print("传统BMI分组分析:")
        traditional_analysis = self.male_data.groupby('BMI分组_传统').agg({
            'Y染色体浓度': ['count', 'mean', 'std'],
            'Y染色体达标': ['sum', 'mean'],
            '孕周数值': ['mean', 'std']
        }).round(4)
        print(traditional_analysis)
        
        print("\n优化BMI分组分析:")
        optimized_analysis = grouping_data.groupby('BMI分组_优化').agg({
            'Y染色体浓度': ['count', 'mean', 'std'],
            'Y染色体达标': ['sum', 'mean'],
            '孕周数值': ['mean', 'std'],
            '孕妇BMI指标': ['min', 'max', 'mean']
        }).round(4)
        print(optimized_analysis)
        
        # 保存分组结果
        self.grouping_results = {
            'traditional_groups': traditional_analysis.to_dict(),
            'optimized_groups': optimized_analysis.to_dict(),
            'group_boundaries': group_boundaries
        }
        
    def enhanced_risk_analysis(self):
        """增强的风险分析（整合T2 v2.2的多维风险函数）"""
        print("\n=== 3. 增强风险分析 ===")
        
        # 准备分析数据
        analysis_data = self.male_data.dropna(subset=[
            '孕妇年龄', '孕妇身高', '孕妇体重', '孕妇BMI指标', '孕周数值', 
            'Y染色体浓度', 'Y染色体达标'
        ]).copy()
        
        # 多维风险函数（基于T2 v2.2思路）
        def calculate_comprehensive_risk(row):
            bmi = row['孕妇BMI指标']
            age = row['孕妇年龄']
            gestational_age = row['孕周数值']
            y_concentration = row['Y染色体浓度']
            
            # 1. BMI风险（主要风险因子）
            bmi_risk = max(0, (bmi - 25) / 10) ** 2
            
            # 2. 年龄风险
            age_risk = max(0, (age - 35) / 10) ** 2
            
            # 3. 时点风险（孕周偏离最优时点）
            optimal_week = 14  # 基于分析结果
            time_risk = abs(gestational_age - optimal_week) / 10
            
            # 4. 浓度风险（Y染色体浓度不足）
            concentration_risk = max(0, (0.04 - y_concentration) * 10)
            
            # 5. 技术风险（基于检测质量）
            technical_risk = 0.1  # 基础技术风险
            
            # 6. 误差风险（检测误差影响）
            error_risk = 0.05  # 基础误差风险
            
            total_risk = bmi_risk + age_risk + time_risk + concentration_risk + technical_risk + error_risk
            
            return {
                'total_risk': total_risk,
                'bmi_risk': bmi_risk,
                'age_risk': age_risk,
                'time_risk': time_risk,
                'concentration_risk': concentration_risk,
                'technical_risk': technical_risk,
                'error_risk': error_risk
            }
        
        # 计算每个样本的风险
        risk_data = []
        for idx, row in analysis_data.iterrows():
            risk_info = calculate_comprehensive_risk(row)
            risk_info['sample_id'] = idx
            risk_info['bmi'] = row['孕妇BMI指标']
            risk_info['age'] = row['孕妇年龄']
            risk_info['gestational_age'] = row['孕周数值']
            risk_info['y_concentration'] = row['Y染色体浓度']
            risk_info['达标状态'] = row['Y染色体达标']
            risk_info['BMI分组_优化'] = row['BMI分组_优化']
            risk_data.append(risk_info)
        
        risk_df = pd.DataFrame(risk_data)
        
        # 按优化分组分析风险
        risk_by_group = risk_df.groupby('BMI分组_优化').agg({
            'total_risk': ['mean', 'std', 'min', 'max'],
            'bmi_risk': 'mean',
            'age_risk': 'mean',
            'time_risk': 'mean',
            'concentration_risk': 'mean',
            'technical_risk': 'mean',
            'error_risk': 'mean',
            '达标状态': ['sum', 'mean', 'count']
        }).round(4)
        
        print("各优化分组的风险分析:")
        print(risk_by_group)
        
        # 保存风险分析结果
        self.risk_analysis = {
            'risk_by_group': risk_by_group.to_dict(),
            'individual_risks': risk_df.to_dict('records')
        }
        
    def optimal_nipt_timing_enhanced(self):
        """增强的最佳NIPT时点分析"""
        print("\n=== 4. 增强最佳NIPT时点分析 ===")
        
        # 为每个优化组确定最佳NIPT时点
        optimal_timing = {}
        
        for group in self.male_data['BMI分组_优化'].unique():
            group_data = self.male_data[self.male_data['BMI分组_优化'] == group]
            
            if len(group_data) < 10:
                continue
                
            # 按孕周分组分析达标率
            gestational_weeks = np.arange(10, 25, 1)
            达标率_by_week = []
            
            for week in gestational_weeks:
                week_data = group_data[
                    (group_data['孕周数值'] >= week) & 
                    (group_data['孕周数值'] < week + 1)
                ]
                if len(week_data) > 0:
                    达标率 = week_data['Y染色体达标'].mean()
                    达标率_by_week.append(达标率)
                else:
                    达标率_by_week.append(np.nan)
            
            # 找到达标率最高的孕周
            valid_indices = ~np.isnan(达标率_by_week)
            if np.any(valid_indices):
                best_week_idx = np.nanargmax(达标率_by_week)
                best_week = gestational_weeks[best_week_idx]
                best_rate =达标率_by_week[best_week_idx]
                
                # 计算该组的风险指标
                group_risk = self.risk_analysis['risk_by_group']['total_risk']['mean'][group]
                
                optimal_timing[group] = {
                    '最佳孕周': float(best_week),
                    '达标率': float(best_rate),
                    '样本数': len(group_data),
                    '平均风险': float(group_risk),
                    '风险等级': self._classify_risk_level(group_risk)
                }
                
                print(f"{group}: 最佳NIPT时点 {best_week:.1f}周, 达标率 {best_rate:.2%}, 风险等级 {self._classify_risk_level(group_risk)}")
        
        # 保存结果
        self.analysis_results['optimal_timing'] = optimal_timing
        
    def _classify_risk_level(self, risk_value):
        """风险等级分类"""
        if risk_value < 0.5:
            return "低风险"
        elif risk_value < 1.0:
            return "中等风险"
        else:
            return "高风险"
    
    def error_impact_analysis_enhanced(self):
        """增强的检测误差影响分析"""
        print("\n=== 5. 增强检测误差影响分析 ===")
        
        # 模拟不同误差水平的影响
        error_levels = [0.01, 0.02, 0.05, 0.1, 0.15, 0.2]
        error_impact = {}
        
        for error_level in error_levels:
            # 添加随机误差
            np.random.seed(42)
            error = np.random.normal(0, error_level, len(self.male_data))
            y_concentration_with_error = self.male_data['Y染色体浓度'] + error
            
            # 重新计算达标率
            达标率_with_error = (y_concentration_with_error >= 0.04).mean()
            原始达标率 = self.male_data['Y染色体达标'].mean()
            
            # 计算误差影响
            影响程度 = abs(达标率_with_error - 原始达标率) / 原始达标率
            
            # 按分组分析误差影响
            group_impact = {}
            for group in self.male_data['BMI分组_优化'].unique():
                group_data = self.male_data[self.male_data['BMI分组_优化'] == group]
                if len(group_data) > 0:
                    group_error = np.random.normal(0, error_level, len(group_data))
                    group_y_concentration_with_error = group_data['Y染色体浓度'] + group_error
                    group_达标率_with_error = (group_y_concentration_with_error >= 0.04).mean()
                    group_原始达标率 = group_data['Y染色体达标'].mean()
                    group_影响程度 = abs(group_达标率_with_error - group_原始达标率) / group_原始达标率
                    
                    group_impact[group] = {
                        '原始达标率': float(group_原始达标率),
                        '误差后达标率': float(group_达标率_with_error),
                        '影响程度': float(group_影响程度)
                    }
            
            error_impact[f'{error_level*100:.0f}%误差'] = {
                '原始达标率': float(原始达标率),
                '误差后达标率': float(达标率_with_error),
                '影响程度': float(影响程度),
                '分组影响': group_impact
            }
            
            print(f"{error_level*100:.0f}%误差: 达标率 {原始达标率:.2%} → {达标率_with_error:.2%}, 影响程度 {影响程度:.2%}")
        
        # 保存结果
        self.analysis_results['error_impact'] = error_impact
        
    def cross_validation_analysis(self):
        """交叉验证分析（整合T2 v2.2思路）"""
        print("\n=== 6. 交叉验证分析 ===")
        
        # 准备数据
        analysis_data = self.male_data.dropna(subset=[
            '孕妇年龄', '孕妇身高', '孕妇体重', '孕妇BMI指标', '孕周数值', 
            'Y染色体浓度', 'Y染色体达标'
        ]).copy()
        
        # 特征选择
        feature_columns = ['孕妇年龄', '孕妇身高', '孕妇体重', '孕妇BMI指标', '孕周数值']
        X = analysis_data[feature_columns]
        y = analysis_data['Y染色体达标']
        
        # 交叉验证
        cv_scores = []
        cv_folds = 5
        
        for fold in range(cv_folds):
            # 随机分割数据
            np.random.seed(fold)
            indices = np.random.permutation(len(analysis_data))
            train_size = int(0.8 * len(analysis_data))
            train_indices = indices[:train_size]
            test_indices = indices[train_size:]
            
            X_train, X_test = X.iloc[train_indices], X.iloc[test_indices]
            y_train, y_test = y.iloc[train_indices], y.iloc[test_indices]
            
            # 训练模型
            model = RandomForestRegressor(n_estimators=100, random_state=42)
            model.fit(X_train, y_train)
            
            # 预测
            y_pred = model.predict(X_test)
            y_pred_binary = (y_pred > 0.5).astype(int)
            
            # 计算准确率
            accuracy = (y_pred_binary == y_test).mean()
            cv_scores.append(accuracy)
        
        # 计算交叉验证结果
        cv_mean = np.mean(cv_scores)
        cv_std = np.std(cv_scores)
        
        print(f"交叉验证准确率: {cv_mean:.4f} ± {cv_std:.4f}")
        
        # 保存结果
        self.analysis_results['cross_validation'] = {
            'cv_scores': cv_scores,
            'cv_mean': float(cv_mean),
            'cv_std': float(cv_std)
        }
        
    def enhanced_visualization(self):
        """增强可视化"""
        print("\n=== 7. 增强可视化 ===")
        
        # 获取结果目录
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(script_dir))))
        results_dir = os.path.join(project_root, 'results', 'T3', 'v1.3')
        os.makedirs(results_dir, exist_ok=True)
        
        # 1. 综合对比分析图
        self._plot_comprehensive_comparison(results_dir)
        
        # 2. 风险分析图
        self._plot_risk_analysis(results_dir)
        
        # 3. 最佳时点分析图
        self._plot_optimal_timing_analysis(results_dir)
        
    def _plot_comprehensive_comparison(self, results_dir):
        """综合对比分析图"""
        plt.figure(figsize=(20, 15))
        
        # 子图1: 传统分组vs优化分组对比
        plt.subplot(3, 4, 1)
        traditional_groups = self.male_data['BMI分组_传统'].value_counts()
        optimized_groups = self.male_data['BMI分组_优化'].value_counts()
        
        x = np.arange(len(traditional_groups))
        width = 0.35
        
        plt.bar(x - width/2, traditional_groups.values, width, label='传统分组', alpha=0.8)
        plt.bar(x + width/2, optimized_groups.values, width, label='优化分组', alpha=0.8)
        
        plt.xlabel('分组')
        plt.ylabel('样本数')
        plt.title('传统分组vs优化分组样本分布')
        plt.xticks(x, traditional_groups.index, rotation=45)
        plt.legend()
        
        # 子图2: 达标率对比
        plt.subplot(3, 4, 2)
        traditional_达标率 = self.male_data.groupby('BMI分组_传统')['Y染色体达标'].mean()
        optimized_达标率 = self.male_data.groupby('BMI分组_优化')['Y染色体达标'].mean()
        
        x = np.arange(len(traditional_达标率))
        plt.bar(x - width/2, traditional_达标率.values, width, label='传统分组', alpha=0.8)
        plt.bar(x + width/2, optimized_达标率.values, width, label='优化分组', alpha=0.8)
        
        plt.xlabel('分组')
        plt.ylabel('达标率')
        plt.title('传统分组vs优化分组达标率对比')
        plt.xticks(x, traditional_达标率.index, rotation=45)
        plt.legend()
        
        # 子图3: Y染色体浓度分布对比
        plt.subplot(3, 4, 3)
        for group in self.male_data['BMI分组_优化'].unique():
            group_data = self.male_data[self.male_data['BMI分组_优化'] == group]
            if len(group_data) > 0:
                plt.hist(group_data['Y染色体浓度'], alpha=0.6, label=group, bins=20)
        plt.axvline(x=0.04, color='red', linestyle='--', linewidth=2, label='达标阈值')
        plt.xlabel('Y染色体浓度')
        plt.ylabel('频数')
        plt.title('优化分组Y染色体浓度分布')
        plt.legend()
        
        # 子图4: 风险分析
        plt.subplot(3, 4, 4)
        if 'individual_risks' in self.risk_analysis:
            risk_df = pd.DataFrame(self.risk_analysis['individual_risks'])
            risk_by_group = risk_df.groupby('BMI分组_优化')['total_risk'].mean()
            
            bars = plt.bar(range(len(risk_by_group)), risk_by_group.values,
                          color=['lightcoral', 'lightblue', 'lightgreen'])
            plt.xticks(range(len(risk_by_group)), risk_by_group.index)
            plt.ylabel('平均风险')
            plt.title('各优化分组平均风险')
            
            # 添加数值标签
            for i, bar in enumerate(bars):
                height = bar.get_height()
                plt.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                        f'{height:.3f}', ha='center', va='bottom')
        
        # 子图5-8: 详细分析
        for i, group in enumerate(self.male_data['BMI分组_优化'].unique()):
            if i >= 4:
                break
                
            plt.subplot(3, 4, 5 + i)
            group_data = self.male_data[self.male_data['BMI分组_优化'] == group]
            
            if len(group_data) > 0:
                scatter = plt.scatter(group_data['孕妇BMI指标'], group_data['Y染色体浓度'], 
                                    c=group_data['Y染色体达标'], cmap='RdYlBu_r', alpha=0.6)
                plt.axhline(y=0.04, color='red', linestyle='--', linewidth=2, label='达标阈值')
                plt.xlabel('BMI')
                plt.ylabel('Y染色体浓度')
                plt.title(f'{group}组详细分析')
                plt.colorbar(scatter, label='达标状态')
                plt.legend()
        
        plt.tight_layout()
        plt.savefig(os.path.join(results_dir, 'T3_v13_综合对比分析.png'), 
                   dpi=300, bbox_inches='tight')
        plt.close()
        
    def _plot_risk_analysis(self, results_dir):
        """风险分析图"""
        plt.figure(figsize=(15, 10))
        
        if 'individual_risks' in self.risk_analysis:
            risk_df = pd.DataFrame(self.risk_analysis['individual_risks'])
            
            # 子图1: 风险分布
            plt.subplot(2, 3, 1)
            plt.hist(risk_df['total_risk'], bins=30, alpha=0.7, color='skyblue', edgecolor='black')
            plt.xlabel('总风险')
            plt.ylabel('频数')
            plt.title('总风险分布')
            
            # 子图2: 各风险因子贡献
            plt.subplot(2, 3, 2)
            risk_components = ['bmi_risk', 'age_risk', 'time_risk', 'concentration_risk', 'technical_risk', 'error_risk']
            risk_means = [risk_df[comp].mean() for comp in risk_components]
            
            bars = plt.bar(risk_components, risk_means, 
                          color=['red', 'orange', 'yellow', 'green', 'blue', 'purple'])
            plt.xticks(rotation=45)
            plt.ylabel('平均风险')
            plt.title('各风险因子贡献')
            
            # 子图3: 风险vs达标率
            plt.subplot(2, 3, 3)
            scatter = plt.scatter(risk_df['total_risk'], risk_df['达标状态'], 
                                alpha=0.6, c=risk_df['bmi'], cmap='viridis')
            plt.xlabel('总风险')
            plt.ylabel('达标状态')
            plt.title('风险vs达标率关系')
            plt.colorbar(scatter, label='BMI')
            
            # 子图4-6: 按分组分析
            for i, group in enumerate(risk_df['BMI分组_优化'].unique()):
                if i >= 3:
                    break
                    
                plt.subplot(2, 3, 4 + i)
                group_risk = risk_df[risk_df['BMI分组_优化'] == group]
                
                plt.hist(group_risk['total_risk'], bins=20, alpha=0.7, 
                        label=f'{group}组', color=plt.cm.Set1(i))
                plt.xlabel('总风险')
                plt.ylabel('频数')
                plt.title(f'{group}组风险分布')
                plt.legend()
        
        plt.tight_layout()
        plt.savefig(os.path.join(results_dir, 'T3_v13_风险分析.png'), 
                   dpi=300, bbox_inches='tight')
        plt.close()
        
    def _plot_optimal_timing_analysis(self, results_dir):
        """最佳时点分析图"""
        plt.figure(figsize=(15, 10))
        
        # 子图1: 各组最佳时点
        plt.subplot(2, 3, 1)
        optimal_timing = self.analysis_results.get('optimal_timing', {})
        groups = list(optimal_timing.keys())
        best_weeks = [optimal_timing[group]['最佳孕周'] for group in groups]
        best_rates = [optimal_timing[group]['达标率'] for group in groups]
        
        bars = plt.bar(groups, best_weeks, 
                      color=['lightcoral', 'lightblue', 'lightgreen'])
        plt.ylabel('最佳孕周')
        plt.title('各优化组最佳NIPT时点')
        
        # 添加数值标签
        for i, bar in enumerate(bars):
            height = bar.get_height()
            plt.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                    f'{height:.1f}周', ha='center', va='bottom')
        
        # 子图2: 最佳时点达标率
        plt.subplot(2, 3, 2)
        bars = plt.bar(groups, best_rates, 
                      color=['lightcoral', 'lightblue', 'lightgreen'])
        plt.ylabel('达标率')
        plt.title('最佳时点达标率')
        plt.ylim(0, 1)
        
        # 子图3: 风险等级分布
        plt.subplot(2, 3, 3)
        risk_levels = [optimal_timing[group]['风险等级'] for group in groups]
        risk_counts = pd.Series(risk_levels).value_counts()
        
        plt.pie(risk_counts.values, labels=risk_counts.index, autopct='%1.1f%%')
        plt.title('风险等级分布')
        
        # 子图4-6: 孕周与达标率关系
        for i, group in enumerate(self.male_data['BMI分组_优化'].unique()):
            if i >= 3:
                break
                
            plt.subplot(2, 3, 4 + i)
            group_data = self.male_data[self.male_data['BMI分组_优化'] == group]
            
            if len(group_data) > 0:
                gestational_weeks = np.arange(10, 25, 1)
                达标率_by_week = []
                
                for week in gestational_weeks:
                    week_data = group_data[
                        (group_data['孕周数值'] >= week) & 
                        (group_data['孕周数值'] < week + 1)
                    ]
                    if len(week_data) > 0:
                        达标率 = week_data['Y染色体达标'].mean()
                        达标率_by_week.append(达标率)
                    else:
                        达标率_by_week.append(np.nan)
                
                valid_indices = ~np.isnan(达标率_by_week)
                if np.any(valid_indices):
                    plt.plot(gestational_weeks[valid_indices], 
                            np.array(达标率_by_week)[valid_indices], 
                            marker='o', linewidth=2, label=f'{group}组')
                    
                    # 标记最佳时点
                    if group in optimal_timing:
                        best_week = optimal_timing[group]['最佳孕周']
                        best_rate = optimal_timing[group]['达标率']
                        plt.axvline(x=best_week, color='red', linestyle='--', alpha=0.7)
                        plt.plot(best_week, best_rate, 'ro', markersize=10)
                
                plt.xlabel('孕周')
                plt.ylabel('达标率')
                plt.title(f'{group}组孕周与达标率关系')
                plt.legend()
                plt.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig(os.path.join(results_dir, 'T3_v13_最佳时点分析.png'), 
                   dpi=300, bbox_inches='tight')
        plt.close()
        
    def generate_comprehensive_report(self):
        """生成综合分析报告"""
        print("\n=== 8. 生成综合分析报告 ===")
        
        # 获取结果目录
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(script_dir))))
        results_dir = os.path.join(project_root, 'results', 'T3', 'v1.3')
        os.makedirs(results_dir, exist_ok=True)
        
        # 生成报告
        report = f"""
# T3 v1.3：综合增强版Y染色体浓度达标时间分析报告

## 问题背景
分析男胎Y染色体浓度达标时间受多种因素（身高、体重、年龄等）的影响，综合考虑这些因素、检测误差和胎儿的Y染色体浓度达标比例（≥4%），根据男胎孕妇的BMI给出合理分组以及每组的最佳NIPT时点，使得孕妇潜在风险最小。

## 版本特点
- **T3 v1.3**: 综合增强版，整合T2 v2.2思路
- **非重叠分组**: 基于T2 v2.2的优化分组算法
- **多维风险函数**: 6个维度的风险评估
- **个性化预测**: 针对不同组的个性化NIPT时点
- **交叉验证**: 改进的验证框架
- **前后连贯**: 与T1、T2逻辑连贯的完整分析

## 分析概述
- 分析时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- 总样本数: {len(self.data)}
- 男胎样本数: {len(self.male_data)}
- Y染色体浓度达标样本数: {self.male_data['Y染色体达标'].sum()}
- Y染色体浓度达标比例: {self.male_data['Y染色体达标'].mean():.2%}

## 主要发现

### 1. 增强BMI分组分析
{self._format_grouping_results()}

### 2. 多维风险分析
{self._format_risk_analysis_results()}

### 3. 最佳NIPT时点
{self._format_optimal_timing_results()}

### 4. 检测误差影响
{self._format_error_impact_results()}

### 5. 交叉验证结果
{self._format_cross_validation_results()}

## 结论与建议

### 主要结论
1. **分组优化**: 基于T2 v2.2的非重叠分组算法显著提升了分组质量
2. **风险分层**: 多维风险函数提供了更精确的风险评估
3. **个性化时点**: 不同组的最佳NIPT时点存在差异，需要个性化制定
4. **误差控制**: 检测误差对结果有显著影响，需要严格控制
5. **逻辑连贯**: 与T1、T2的分析思路保持逻辑连贯

### 临床建议
1. **个性化检测**: 根据优化分组制定个性化的NIPT检测策略
2. **风险分层管理**: 基于多维风险函数进行精确的风险分层
3. **质量控制**: 严格控制检测误差，确保结果可靠性
4. **动态调整**: 根据实际情况动态调整检测策略
5. **综合评估**: 结合T1、T2的分析结果进行综合评估

## 技术说明

本分析整合了以下技术：
- T2 v2.2的非重叠分组算法
- 多维风险函数评估
- 个性化NIPT时点预测
- 改进的交叉验证框架
- 增强的可视化分析
- 前后逻辑连贯的完整分析流程

---
*报告生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
*版本: T3 v1.3 综合增强版*
        """
        
        # 保存报告
        with open(os.path.join(results_dir, 'T3_v13_综合增强分析报告.md'), 'w', encoding='utf-8') as f:
            f.write(report)
            
        # 保存分析结果
        with open(os.path.join(results_dir, 'T3_v13_分析结果.json'), 'w', encoding='utf-8') as f:
            json.dump({
                'analysis_results': self.analysis_results,
                'grouping_results': self.grouping_results,
                'risk_analysis': self.risk_analysis
            }, f, indent=2, ensure_ascii=False, default=str)
            
        print(f"综合分析报告已保存到: {results_dir}")
        
    def _format_grouping_results(self):
        """格式化分组结果"""
        if not self.grouping_results:
            return "分组数据不可用"
        
        lines = []
        lines.append("#### 传统BMI分组:")
        traditional_groups = self.grouping_results.get('traditional_groups', {})
        if traditional_groups:
            for group, data in traditional_groups.items():
                if isinstance(data, dict) and 'Y染色体达标' in data:
                    达标率 = data['Y染色体达标'].get('mean', 0)
                    lines.append(f"- **{group}**: 达标率 {达标率:.2%}")
        
        lines.append("\n#### 优化BMI分组:")
        optimized_groups = self.grouping_results.get('optimized_groups', {})
        if optimized_groups:
            for group, data in optimized_groups.items():
                if isinstance(data, dict) and 'Y染色体达标' in data:
                    达标率 = data['Y染色体达标'].get('mean', 0)
                    lines.append(f"- **{group}**: 达标率 {达标率:.2%}")
        
        return "\n".join(lines)
        
    def _format_risk_analysis_results(self):
        """格式化风险分析结果"""
        if not self.risk_analysis:
            return "风险分析数据不可用"
        
        lines = []
        risk_by_group = self.risk_analysis.get('risk_by_group', {})
        if risk_by_group:
            for group, data in risk_by_group.items():
                if isinstance(data, dict) and 'total_risk' in data:
                    total_risk = data['total_risk'].get('mean', 0)
                    lines.append(f"- **{group}**: 平均风险 {total_risk:.3f}")
        
        return "\n".join(lines)
        
    def _format_optimal_timing_results(self):
        """格式化最佳时点结果"""
        timing_data = self.analysis_results.get('optimal_timing', {})
        if not timing_data:
            return "最佳时点数据不可用"
        
        lines = []
        for group, data in timing_data.items():
            lines.append(f"- **{group}**: {data['最佳孕周']:.1f}周, 达标率 {data['达标率']:.2%}, 风险等级 {data['风险等级']}")
        
        return "\n".join(lines)
        
    def _format_error_impact_results(self):
        """格式化误差影响结果"""
        error_data = self.analysis_results.get('error_impact', {})
        if not error_data:
            return "误差影响数据不可用"
        
        lines = []
        for level, data in error_data.items():
            lines.append(f"- **{level}**: 影响程度 {data['影响程度']:.2%}")
        
        return "\n".join(lines)
        
    def _format_cross_validation_results(self):
        """格式化交叉验证结果"""
        cv_data = self.analysis_results.get('cross_validation', {})
        if not cv_data:
            return "交叉验证数据不可用"
        
        cv_mean = cv_data.get('cv_mean', 0)
        cv_std = cv_data.get('cv_std', 0)
        return f"交叉验证准确率: {cv_mean:.4f} ± {cv_std:.4f}"
        
    def run_complete_analysis(self):
        """运行完整分析"""
        print("🚀 开始T3 v1.3 综合增强版Y染色体浓度达标时间分析...")
        
        # 1. 数据加载与预处理
        self.load_and_preprocess_data()
        
        # 2. 增强BMI分组分析
        self.enhanced_bmi_grouping()
        
        # 3. 增强风险分析
        self.enhanced_risk_analysis()
        
        # 4. 增强最佳NIPT时点分析
        self.optimal_nipt_timing_enhanced()
        
        # 5. 增强检测误差影响分析
        self.error_impact_analysis_enhanced()
        
        # 6. 交叉验证分析
        self.cross_validation_analysis()
        
        # 7. 增强可视化
        self.enhanced_visualization()
        
        # 8. 生成综合报告
        self.generate_comprehensive_report()
        
        print("✅ T3 v1.3 综合增强版Y染色体浓度达标时间分析完成！")

if __name__ == "__main__":
    # 创建分析实例
    analyzer = T3IntegratedAnalysis()
    
    # 运行完整分析
    analyzer.run_complete_analysis()
